# Chunk 1
2 + 2
# Chunk 2
4 * (3 + 5) # La somma entro parentesi viene eseguita per prima
# Chunk 3
from numpy import pi
pi / 4 # Pi greco quarti
# Chunk 4
2**5
# Chunk 5
import numpy as np
np.sqrt(2)
# Chunk 6
np.sin(pi / 4)
# Chunk 7
# Assegna il valore 5 all'oggetto x
x = np.sqrt(5)
# Chunk 8
y = x + pi # ovvero pi greco + radice quadrata di 5
y
# Chunk 9
del x # x non è più presente nel "workspace"
# Chunk 11
x = 1/2 # Esempio di numero reale
# Chunk 12
np.exp(x) # Esponenziale e logaritmo naturale
# Chunk 13
np.log(x)
# Chunk 14
np.abs(x) # Valore assoluto
# Chunk 15
np.sign(x) # Funzione segno
# Chunk 16
np.sin(x) # Funzioni trigonometriche (seno, coseno, tangente)
# Chunk 17
np.cos(x)
# Chunk 18
np.tan(x)
# Chunk 19
np.arcsin(x) # Funzioni trigonometriche (seno, coseno, tangente)
# Chunk 20
np.arccos(x)
# Chunk 21
np.arctan(x)
# Chunk 22
x = 1 / 2; y = 1 / 3 # Numeri reali
n = 5; k = 2 # Numeri naturali
import scipy.special as scp
scp.factorial(n) # n!
scp.binom(n, k) # Coefficiente binomiale
np.around(x, 2) # Arrotonda x usando 2 cifre decimali
np.ceil(x) # Arrotonda x all'intero più vicino, per eccesso
scp.beta(x, y) # Funzione beta
scp.gamma(x) # Funzione gamma
10**15
n <- 10
sum((-1)^(1:n) * (1:n) * choose(n, 1:n))
sum((-1)^(1:n + 1) * (1:n) * choose(n, 1:n))
1:n + 1
(-1)^(1:n + 1)
(-1)^(1:n + 1) * (1:n) * choose(n, 1:n)
(-1)^(1:n) * (1:n) * choose(n, 1:n)
sum((-1)^(1:(n + 1)) * (1:n) * choose(n, 1:n))
n <- 10
id <- 1:(n + 1)
sum((-1)^(1:id) * (1:id) * choose(n, 1:id))
n <- 10
id <- 1:(n + 1)
sum((-1)^(1:id) * (1:id) * choose(n, 1:id))
n <- 10
dist_euclid <- function(x, y) {
sqrt(crossprod(x - y))
}
dist_euclid <- function(x, y) {
sqrt(crossprod(x - y))
}
x <- rnorm(10)
y <- rnorm(10)
dist_euclid(x, y)
sqrt(sum(x-y)^2))
sqrt(sum(x-y)^2)
sqrt(sum((x-y)^2))
library(microbenchm)
library(microbenchmark)
install.packages("microbenchmark")
library(microbenchmark)
microbenchmark(dist_euclid(x,y ))
microbenchmark(dist_euclid(x, y), sqrt(sum((x-y)^2)))
microbenchmark(dist_euclid(x, y), sqrt(sum((x-y)^2)))
microbenchmark(dist_euclid(x, y), sqrt(sum((x-y)^2)))
microbenchmark(sqrt(crossprod(x - y)), sqrt(sum((x-y)^2)))
microbenchmark(sqrt(crossprod(x - y)), sqrt(sum((x-y)^2)))
microbenchmark(sqrt(crossprod(x - y)), sqrt(sum((x-y)^2)))
microbenchmark(sqrt(crossprod(x - y)), sqrt(sum((x-y)^2)))
# Chunk 1
titanic <- read.table("../dataset/titanic.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)
setwd("~/Library/Mobile Documents/com~apple~CloudDocs/University/Didattica/Laboratorio Statistica/introR/lezioni")
# Chunk 1
titanic <- read.table("../dataset/titanic.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)
# Chunk 3
str(titanic)
# Chunk 4
summary(titanic)
# Chunk 5
freq_abs_classe <- table(titanic$Classe)
freq_rel_classe <- freq_abs_classe / sum(freq_abs_classe)
tab_summary <- cbind(freq_abs_classe, freq_rel_classe)
tab_summary
# Chunk 6
tab <- table(titanic$Salvato, titanic$Classe)
tab
# Chunk 7
addmargins(tab) # Aggiunge le distribuzioni marginali (assolute)
# Chunk 8
tab_rel <- prop.table(tab) # Comando alternativo: table(tab) / sum(tab)
tab_rel
addmargins(tab_rel) # Aggiunge le distribuzioni marginali relative
barplot(tab)
barplot(tab, density = TRUE)
barplot(tab, beside = TRUE)
barplot(prop.table(tab, 1), beside = TRUE) # Beside = TRUE "affianca" i rettangoli.
barplot(prop.table(tab, 1), beside = FALSE) # Beside = TRUE "affianca" i rettangoli.
barplot(t(prop.table(tab, 1)), beside = FALSE) # Beside = FALSE "affianca" i rettangoli.
barplot(prop.table(tab, 2), beside = FALSE) # Beside = FALSE "incolonna" i rettangoli.
prop.table(tab, 2)
barplot(prop.table(tab, 2), beside = FALSE, legend.text = c("Si", "No")) # Beside = FALSE "incolonna" i rettangoli.
barplot(prop.table(tab, 2), beside = FALSE,
legend.text = TRUE) # Beside = FALSE "mette in colonna" i rettangoli.
barplot(prop.table(tab, 2), beside = FALSE,
xlab = "Classe",
legend.text = TRUE) # Beside = FALSE "mette in colonna" i rettangoli.
library(ggplot2)
ggplot(data = titanic, aes(x = Classe, y = Esito)) + geom_bar()
View(titanic)
ggplot(data = titanic, aes(x = Classe, y = Salvato)) + geom_bar()
ggplot(data = titanic, aes(x = Classe, y = Salvato)) + geom_bar()
ggplot(data = titanic, aes(x = Classe, col = Salvato)) + geom_bar()
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) + geom_bar()
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) + geom_bar() + theme_bw()
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) + geom_bar(stat = "density") + theme_bw()
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) + geom_bar(stat = "count") + theme_bw()
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) + geom_bar(position = "dodge") + theme_bw()
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) + geom_bar(position = "dodge") + theme_bw() + xlab("Frequenze assolute")
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) + geom_bar(position = "dodge") + theme_bw() + ylab("Frequenze assolute")
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) +
geom_bar(position = "dodge") +
theme_bw() +
scale_fill_brewer(type = "Set3") +
ylab("Frequenze assolute")
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) +
geom_bar(position = "dodge") +
theme_bw() +
scale_fill_brewer(palette = "Set3") +
ylab("Frequenze assolute")
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) +
geom_bar(position = "dodge") +
theme_bw() +
scale_fill_brewer(palette = "Dark2") +
ylab("Frequenze assolute")
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) +
geom_bar(position = "dodge") +
theme_bw(legend.position = "top") +
scale_fill_brewer(palette = "Dark2") +
ylab("Frequenze assolute")
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) +
geom_bar(position = "dodge") +
theme_bw() + theme(legend.position = "top") +
scale_fill_brewer(palette = "Dark2") +
ylab("Frequenze assolute")
barplot(tab, beside = TRUE, legend.text = TRUE) # Beside = TRUE "affianca" i rettangoli.
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) +
geom_bar(position = "fill") +
theme_bw() + theme(legend.position = "top") +
scale_fill_brewer(palette = "Dark2") +
ylab("Frequenze assolute")
ggplot(data = titanic, aes(x = Classe, fill = Salvato)) +
geom_bar(position = "fill") +
theme_bw() + theme(legend.position = "top") +
scale_fill_brewer(palette = "Dark2") +
ylab("Frequenze relative")
styler:::style_active_file()
R <- 5000 # Numero di repliche
set.seed(123)
X <- rnorm(R, 0, 1) # Ottengo R copie da una distribuzione gaussiana
Y <- cos(X) # Ottengo R copie dalla distribuzione di Y
Z <- Y > 0 # Vettore logico che verifica se Y > 0 o meno
as.numeric(Z)
dataset <- rbind(1:R, cumsum(as.numeric(Z)) / (1:R))
dataset
write.csv(dataset, "flourish.csv", col.names = FALSE, row.names = FALSE)
write.csv(dataset, "flourish.csv", colnames = FALSE, row.names = FALSE)
write.csv(dataset, "flourish.csv", row.names = FALSE)
colnames(dataset) <- 1:R
write.csv(dataset, "flourish.csv", row.names = FALSE)
write.csv(dataset, "flourish.csv", row.names = FALSE, col.names = FALSE)
seq(from = 100, to = 5000, by = 100)
colnames(dataset) <- 1:R
dataset <- dataset[, seq(from = 100, to = 5000, by = 100)]
write.csv(dataset, "flourish.csv", row.names = FALSE)
R <- 5000 # Numero di repliche
set.seed(123)
X <- # Ottengo R copie da una distribuzione gaussiana
Y <- cos(X) # Ottengo R copie dalla distribuzione di Y
Z <- Y > 0 # Vettore logico che verifica se Y > 0 o meno
dataset <- rbind(cumsum(as.numeric(cos(rnorm(R, 0, 1) ) > 0)) / (1:R),
cumsum(as.numeric(cos(rnorm(R, 0, 1) ) > 0)) / (1:R),
cumsum(as.numeric(cos(rnorm(R, 0, 1) ) > 0)) / (1:R))
colnames(dataset) <- 1:R
dataset <- dataset[, seq(from = 100, to = 5000, by = 100)]
write.csv(dataset, "flourish.csv", row.names = FALSE)
R <- 50000 # Numero di repliche
set.seed(123)
X <- # Ottengo R copie da una distribuzione gaussiana
Y <- cos(X) # Ottengo R copie dalla distribuzione di Y
Z <- Y > 0 # Vettore logico che verifica se Y > 0 o meno
dataset <- rbind(cumsum(as.numeric(cos(rnorm(R, 0, 1) ) > 0)) / (1:R),
cumsum(as.numeric(cos(rnorm(R, 0, 1) ) > 0)) / (1:R),
cumsum(as.numeric(cos(rnorm(R, 0, 1) ) > 0)) / (1:R))
colnames(dataset) <- 1:R
dataset <- dataset[, seq(from = 100, to = 50000, by = 500)]
write.csv(dataset, "flourish.csv", row.names = FALSE)
R <- 10000 # Numero di repliche
set.seed(123)
X <- # Ottengo R copie da una distribuzione gaussiana
Y <- cos(X) # Ottengo R copie dalla distribuzione di Y
Z <- Y > 0 # Vettore logico che verifica se Y > 0 o meno
dataset <- rbind(cumsum(as.numeric(cos(rnorm(R, 0, 1) ) > 0)) / (1:R),
cumsum(as.numeric(cos(rnorm(R, 0, 1) ) > 0)) / (1:R),
cumsum(as.numeric(cos(rnorm(R, 0, 1) ) > 0)) / (1:R))
colnames(dataset) <- 1:R
dataset <- dataset[, seq(from = 100, to = 10000, by = 200)]
write.csv(dataset, "flourish.csv", row.names = FALSE)
