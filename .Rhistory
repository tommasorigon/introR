}
my_sd(emo_A)
my_sd(emo_B)
sd(emo_A)
sd(emo_B)
# Chunk 10
max(emo_A) - min(emo_A)
max(emo_B) - min(emo_B)
diff(range(emo_A))
diff(range(emo_B))
# Chunk 11
interquartile_range <- function(x){
diff(quantile(x, probs = c(0.25, 0.75)))
}
interquartile_range(emo_A)
interquartile_range(emo_B)
# Chunk 12
MAD <- function(x) {
median(abs(x - median(x)))
}
# Chunk 13
MAD(emo_A)
MAD(emo_B)
# Chunk 14
tapply(emoglobina$emoglobina, emoglobina$Metodologia, mean)
with(emoglobina, tapply(emoglobina, Metodologia, mean)) # In maniera ancora più compatta
# Chunk 15
tab <- rbind(with(emoglobina, tapply(emoglobina, Metodologia, my_var)),
with(emoglobina, tapply(emoglobina, Metodologia, my_sd)),
with(emoglobina, tapply(emoglobina, Metodologia, interquartile_range)),
with(emoglobina, tapply(emoglobina, Metodologia, MAD)))
rownames(tab) <- c("Varianza", "Deviazione Standard", "Scarto interquartile", "MAD")
tab
# Prima possibile implementazione
asym <- function(x){
sqm <- sqrt(mean(x^2) - mean(x)^2)
mean((x - mean(x))^3) / sqm^3
}
# Implementazione (leggermente) alternativa
asym <- function(x){
sqm <- sqrt(mean(x^2) - mean(x)^2)
z <- (x - mean(x)) / sqm
mean(z^3)
}
asym(emo_A)
forbes <- read.table("../dataset/forbes.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)
forbes
forbes <- read.table("../dataset/forbes.csv", header = TRUE, sep = ",")
install.packages(c("BDgraph", "blob", "brew", "Brobdingnag", "broom", "bslib", "callr", "car", "checkmate", "chron", "cli", "cluster", "commonmark", "cpp11", "crayon", "cubature", "curl", "data.table", "DBI", "dbplyr", "dendextend", "desc", "devtools", "digest", "dotCall64", "dplyr", "DT", "dtplyr", "emmeans", "evaluate", "expint", "farver", "fields", "fontawesome", "forcats", "foreign", "GA", "gargle", "generics", "gert", "ggforce", "ggraph", "ggsignif", "gh", "gitcreds", "googlesheets4", "graphlayouts", "gtable", "gtools", "gtrendsR", "haven", "hms", "htmltools", "httpuv", "httr", "igraph", "IRkernel", "isoband", "jsonlite", "knitr", "lifecycle", "lme4", "lpSolve", "maps", "maptools", "markdown", "MASS", "Matrix", "MatrixModels", "matrixStats", "mcclust", "mclust", "mgcv", "minqa", "mnormt", "modelr", "nlme", "nloptr", "nnet", "openssl", "packrat", "pbdZMQ", "pillar", "pkgload", "polyclip", "processx", "ps", "purrr", "quantreg", "R.cache", "R.methodsS3", "R.oo", "R.utils", "raster", "Rcpp", "RcppArmadillo", "RcppEigen", "readr", "readxl", "reprex", "reticulate", "rlang", "rmarkdown", "roxygen2", "rpart", "rprojroot", "rsconnect", "rstan", "rstudioapi", "rversions", "rvest", "sass", "scales", "shiny", "shinyWidgets", "sm", "sn", "sp", "spam", "splines2", "statmod", "stringi", "stringr", "styler", "survival", "sys", "terra", "testthat", "tibble", "tictoc", "tidygraph", "tidyr", "tidyselect", "tidyverse", "timechange", "tinytex", "tsibble", "tweenr", "usethis", "uuid", "vctrs", "vegan", "viridisLite", "vroom", "xfun", "xts", "yaml", "zip", "zoo"))
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
titanic <- read.table("../dataset/titanic.csv", header = TRUE, sep = ",")
titanic <- read.table("../dataset/titanic.csv", header = TRUE, sep = ",")
str(titanic)
summary(titanic)
titanic <- read.table("../dataset/titanic.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)
titanic <- read.table(path, header = TRUE, sep = ",", stringsAsFactors = TRUE)
#| eval: false
path <- "https://tommasorigon.github.io/introR/data/titanic.csv"
titanic <- read.table(path, header = TRUE, sep = ",", stringsAsFactors = TRUE)
str(titanic)
summary(titanic)
freq_abs_classe <- table(titanic$Classe)
freq_rel_classe <- freq_abs_classe / sum(freq_abs_classe)
tab_summary <- cbind(freq_abs_classe, freq_rel_classe)
tab_summary
titanic <- read.table("../dataset/titanic.csv", header = TRUE, sep = ",", stringsAsFactors = TRUE)
str(titanic)
summary(titanic)
freq_abs_classe <- table(titanic$Classe)
freq_rel_classe <- freq_abs_classe / sum(freq_abs_classe)
tab_summary <- cbind(freq_abs_classe, freq_rel_classe)
tab_summary
tab <- table(titanic$Salvato, titanic$Classe)
tab
addmargins(tab) # Aggiunge le distribuzioni marginali (assolute)
tab_rel <- prop.table(tab) # Comando alternativo: table(tab) / sum(tab)
tab_rel
addmargins(tab_rel) # Aggiunge le distribuzioni marginali relative
chi_squared <- function(x, y) {
nn <- table(x, y)
n <- sum(nn)
ff <- nn / n # Frequenze relative congiunte
f_x <- table(x) / n # Frequenze relative marginali di x
f_y <- table(y) / n # Frequenze relative marginali di y
S <- 0
for (i in 1:length(f_x)) {
for (j in 1:length(f_y)) {
S <- S + ff[i, j]^2 / (f_x[i] * f_y[j])
}
}
n * (S - 1)
}
chi_squared(titanic$Salvato, titanic$Classe)
# Chunk 1
n <- 10 # Numero di tentativi
p <- 0.6 # Probabilità di successo
k <- 4 # Numero di successi
choose(n, k) * p^k * (1 - p)^(n - k)
# Chunk 2
dbinom(k, size = n, prob = p)
# Chunk 3
sum(dbinom(0:5, size = n, prob = p))
pbinom(5, size = n, prob = p) # Funzione specifica di R
styler:::style_active_file()
kk <- 0:n
prob <- dbinom(0:n, size = n, prob = p)
plot(kk, prob, type = "h", main = "Bin(10,0.6)", xlab = "k", ylab = "P(X=k)")
x <- 1 # Punto in cui calcolare f(x)
mu <- 3 # Media
sigma2 <- 10 # Varianza
1 / sqrt(2 * pi * sigma2) * exp(-1 / (2 * sigma2) * (x - mu)^2)
dnorm(x, mean = 3, sd = sqrt(sigma2))
x <- 1 # Punto in cui calcolare f(x)
mu <- 3 # Media
sigma2 <- 10 # Varianza
1 / sqrt(2 * pi * sigma2) * exp(-1 / (2 * sigma2) * (x - mu)^2)
dnorm(x, mean = 3, sd = sqrt(sigma2))
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
curve(cos(50 * x) + sin(20 * x))
curve((cos(50 * x) + sin(20 * x))^2)
curve((cos(50 * x) + sin(20 * x))^2, n = 200)
curve((cos(50 * x) + sin(20 * x))^2, n = 400)
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
# Chunk 1
R <- 5000 # Numero di repliche
set.seed(123)
X <- rnorm(R, 0, 1) # Ottengo R copie da una distribuzione gaussiana
Y <- cos(X) # Ottengo R copie dalla distribuzione di Y
Z <- Y > 0 # Vettore logico che verifica se Y > 0 o meno
Z[1:10]
# Chunk 2
prop.table(table(Z)) # Considero la frequenza relativa
mean(Z) # Oppure, più semplicemente
# Chunk 3
set.seed(100) # Imposto un seed diverso da prima
Z <- cos(rnorm(R, 0, 1)) > 0 # Calcolo gli indicatori (codice in forma compatta)
mean(Z)
# Chunk 4
MonteCarlo <- function(R) {
Z <- cos(rnorm(R, 0, 1)) > 0
estimate <- mean(Z)
std.error <- sqrt(estimate * (1 - estimate) / R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error") # Aggiungo solo per ragioni estetiche
out
}
# Chunk 5
MonteCarlo(100) # R = 100 conduce a uno std.error elevato
MonteCarlo(5000) # R = 5000 conduce a uno std.error ragionevole
MonteCarlo(10^6) # R = 10^6 conduce a uno std.error basso
# Chunk 6
MonteCarlo <- function(R) {
X <- rnorm(R)
Z <- (X > 1) & (X < 2)
estimate <- mean(Z)
std.error <- sqrt(estimate * (1 - estimate) / R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error")
out
}
# Vero valore
pnorm(2) - pnorm(1)
MonteCarlo(100) # R = 100 conduce a std.error elevato
MonteCarlo(5000) # R = 5000 conduce a std.error ragionevole
MonteCarlo(10^6) # R = 10^6 conduce a std.error basso
# Chunk 7
U <- runif(10^6)
I_hat <- mean((cos(50 * U) + sin(20 * U))^2)
I_hat
# Chunk 8
curve((cos(50 * x) + sin(20 * x))^2, n = 400)
# Chunk 9
MonteCarlo <- function(R) {
U <- runif(R)
hU <- (cos(50 * U) + sin(20 * U))^2
estimate <- mean(hU)
std.error <- sd(hU) / sqrt(R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error") # Aggiungo solo per ragioni estetiche
out
}
# Chunk 10
MonteCarlo(100) # R = 100 conduce a uno std.error elevato
MonteCarlo(5000) # R = 5000 conduce a uno std.error ragionevole
MonteCarlo(10^6) # R = 10^6 conduce a uno std.error basso
# Chunk 11
X <- rnorm(10^5)
hX <- sin(X)^2
mean(hX) # Estimate
sd(hX) / sqrt(10^5) # Std.error
# Integrazione numerica
integrate(function(x) sin(x)^2 * dnorm(x), -Inf, Inf)
# Chunk 12
mean(rgamma(10^5, 3, 3) * rgamma(10^5, 3, 3))
# Chunk 13
X <- rgamma(10^5, 3, 3)
mean(X * X)
# Chunk 14
X <- rnorm(10^5)
hist(X, freq = FALSE, breaks = 100)
curve(dnorm(x), add = TRUE) # add = TRUE Aggiunge la curva al grafico precedente
X <- rpois(10^5, 10) # Simulazione di R variabili Poisson con media 10
freq_rel <- table(X) / n # Calcolo delle frequenze relative
X <- rpois(10^5, 10) # Simulazione di R variabili Poisson con media 10
freq_rel <- table(X) / n # Calcolo delle frequenze relative
table(X)
X <- rpois(10^5, 10) # Simulazione di R variabili Poisson con media 10
freq_rel <- table(X) / sum(X) # Calcolo delle frequenze relative
par(mfrow = c(1, 2)) # Grafici
plot(freq_rel, ylab = "P(X = k)", xlab = "k", main = "Distribuzione empirica")
plot(0:28, dpois(0:28, 10),
type = "h", ylab = "P(X = k)",
xlab = "k", main = "Distribuzione teorica"
)
sample(1:n)
n <- 100 # Numero di prigionieri
# Numeri nelle scatole (generati casualmente)
boxes <- sample(1:n)
# Numeri nelle scatole (generati casualmente, non conosciuti dai prigionari)
set.seed(400)
boxes <- sample(1:n)
# Per cui, nella scatola 51, è contenuto il numero
boxes[51]
n <- 100 # Numero di prigionieri
# Numeri nelle scatole (generati casualmente, non conosciuti dai prigionari)
set.seed(400)
boxes <- sample(1:n)
# Per cui, nella scatola 51, è contenuto il numero
boxes[51]
# In questa specifica simulazione, le scatole contengono i numeri seguenti
boxes
prisoners[1] == boxes[1]
# Lista dei prigionieri
prisoners <- 1:100
prisoners[1] == boxes[1]
prisoners[1]
# Loop strategy, per il PRIMO prigioniero
found <- FALSE
box_checked <- 1 # Il primo prigioniero, parte dalla prima scatola
for(i in 2:(n / 2)) {
if(boxes[box_checked] == 1) found <- TRUE
}
found
# Loop strategy, per il PRIMO prigioniero
found <- FALSE
box_checked <- 1 # Il primo prigioniero, parte dalla prima scatola
for(i in 2:(n / 2)) {
if(boxes[box_checked] == 1) {
found <- TRUE
} #
box_checked <- boxes[box_checked]
}
found
found <- rep(FALSE, n)
found <- rep(FALSE, n)
for(j in 1:n){
box_checked <- j # Il j-esimo prigioniero, parte dalla j-esima scatola
for(i in 2:(n / 2)) {
if(boxes[box_checked] == 1) {
found[j] <- TRUE
} #
box_checked <- boxes[box_checked]
}
}
found
found <- rep(FALSE, n)
for(j in 1:n){
box_checked <- j # Il j-esimo prigioniero, parte dalla j-esima scatola
for(i in 2:(n / 2)) {
if(boxes[box_checked] == j) {
found[j] <- TRUE
} #
box_checked <- boxes[box_checked]
}
}
found
found <- rep(FALSE, n)
for(j in 1:n){
box_checked <- j # Il j-esimo prigioniero, parte dalla j-esima scatola
for(i in 2:(n / 2)) {
if(boxes[box_checked] == j) {
found[j] <- TRUE
} #
box_checked <- boxes[box_checked]
}
}
found
all(found)
found
loop_strategy <- function(n){
boxes <- sample(1:n) # Effettua una permutazione dei numeri 1:n
found <- rep(FALSE, n)
for(j in 1:n){
box_checked <- j # Il j-esimo prigioniero, parte dalla j-esima scatola
for(i in 2:(n / 2)) {
if(boxes[box_checked] == j) {
found[j] <- TRUE
}
box_checked <- boxes[box_checked]
}
}
}
replicate(loop_strategy(n = 100), 1000)
replicate(1000, loop_strategy(n = 100))
loop_strategy(n = 100)
loop_strategy <- function(n){
boxes <- sample(1:n) # Effettua una permutazione dei numeri 1:n
found <- rep(FALSE, n)
for(j in 1:n){
box_checked <- j # Il j-esimo prigioniero, parte dalla j-esima scatola
for(i in 2:(n / 2)) {
if(boxes[box_checked] == j) {
found[j] <- TRUE
}
box_checked <- boxes[box_checked]
}
}
all(found)
}
loop_strategy(n = 100)
loop_strategy(n = 100)
replicate(1000, loop_strategy(n = 100))
Z <- replicate(1000, loop_strategy(n = 100))
mean(Z)
Z <- replicate(1000, loop_strategy(n = 100))
estimate <- mean(Z)
std.error <- sqrt(estimate * (1 - estimate) / R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error") # Aggiungo solo per ragioni estetiche
out
# Effettuo la simulazione, per R = 1000
Z <- replicate(R = 1000, loop_strategy(n = 100))
# Effettuo la simulazione, per R = 1000
Z <- replicate(1000, loop_strategy(n = 3000))
# Effettuo la simulazione, per R = 1000
Z <- replicate(1000, loop_strategy(n = 100))
estimate <- mean(Z)
std.error <- sqrt(estimate * (1 - estimate) / R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error") # Aggiungo solo per ragioni estetiche
out
# Effettuo la simulazione, per R = 10000
Z <- replicate(10000, loop_strategy(n = 100))
estimate <- mean(Z)
std.error <- sqrt(estimate * (1 - estimate) / R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error") # Aggiungo solo per ragioni estetiche
out
# Effettuo la simulazione, per R = 10000
Z <- replicate(10000, loop_strategy(n = 100))
# Effettuo la simulazione, per R = 10000
R <- 10000
Z <- replicate(R, loop_strategy(n = 100))
estimate <- mean(Z)
std.error <- sqrt(estimate * (1 - estimate) / R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error") # Aggiungo solo per ragioni estetiche
out
found <- rep(FALSE, n)
for(j in 1:n){
box_checked <- j # Il j-esimo prigioniero, parte dalla j-esima scatola
for(i in 1:(n / 2)) {
if(boxes[box_checked] == j) {
found[j] <- TRUE
}
box_checked <- boxes[box_checked]
}
}
found
all(found)
loop_strategy <- function(n){
boxes <- sample(1:n) # Effettua una permutazione dei numeri 1:n
found <- rep(FALSE, n)
for(j in 1:n){
box_checked <- j # Il j-esimo prigioniero, parte dalla j-esima scatola
for(i in 1:(n / 2)) {
if(boxes[box_checked] == j) {
found[j] <- TRUE
}
box_checked <- boxes[box_checked]
}
}
all(found)
}
# Effettuo la simulazione, per R = 10000
R <- 10000
Z <- replicate(R, loop_strategy(n = 100))
# Effettuo la simulazione, per R = 10000
R <- 10000
set.seed(200)
Z <- replicate(R, loop_strategy(n = 100))
estimate <- mean(Z) # Stima della probabilità di successo
std.error <- sqrt(estimate * (1 - estimate) / R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error") # Aggiungo solo per ragioni estetiche
out
styler:::style_active_file()
# Chunk 1
set.seed(100)
n <- 20 # Numerosità campionaria
mu <- 10 # Media teorica (solitamente ignota)
# Campione y_1,...,y_n
y <- rnorm(n, mean = mu, sd = sqrt(16))
# Vero valore è mu = 10
mean(x)
# Chunk 1
set.seed(100)
n <- 20 # Numerosità campionaria
mu <- 10 # Media teorica (solitamente ignota)
# Campione y_1,...,y_n
y <- rnorm(n, mean = mu, sd = sqrt(16))
# Vero valore è mu = 10
mean(y)
median(y)
# Chunk 2
set.seed(156)
R <- 10^5
# Ottengo R estrazioni della mediana campionaria Me_1,...Me_R
median_hat <- replicate(R, median(rnorm(n = n, mean = mu, sd = sqrt(16))))
# Chunk 3
mean((median_hat - mu)^2) # Stima dello scarto quadratico medio (MSE) della mediana
# Chunk 4
set.seed(156)
R <- 10^5
mu_hat <- replicate(R, mean(rnorm(n = n, mean = mu, sd = sqrt(16))))
median_hat <- replicate(R, median(rnorm(n = n, mean = mu, sd = sqrt(16))))
mean(mu_hat) - mu # Distorsione dello stimatore; valore teorico: 0
mean((mu_hat - mu)^2) # Scarto quadratico medio dello stimatore; valore teorico: 0.8
mean(median_hat) - mu # Distorsione dello stimatore; valore teorico: ??
mean((median_hat - mu)^2) # Scarto quadratico medio dello stimatore; valore teorico: ??
# Chunk 5
par(mfrow = c(1, 2))
hist(mu_hat, breaks = 100, freq = F)
hist(median_hat, breaks = 100, freq = F)
# Chunk 6
set.seed(520)
R <- 10^5; n <- 20
mu <- 0; sigma2 <- 16
# Definisco le funzioni che calcolano gli stimatori
var1 <- function(x) mean(x^2) - mean(x)^2
var2 <- function(x) var(x) # Coincide con la definizione di R
var3 <- function(x) mean(x^2)
var4 <- function(x) (length(x) - 1) / (length(x) + 1) * var(x)
# Esecuzione della simulazione
S2_1 <- replicate(R, var1(rnorm(n = n, mean = mu, sd = sqrt(sigma2))))
S2_2 <- replicate(R, var2(rnorm(n = n, mean = mu, sd = sqrt(sigma2))))
S2_3 <- replicate(R, var3(rnorm(n = n, mean = mu, sd = sqrt(sigma2))))
S2_4 <- replicate(R, var4(rnorm(n = n, mean = mu, sd = sqrt(sigma2))))
# Distorsioni (approssimate)
round(mean(S2_1 - sigma2), 2)
round(mean(S2_2 - sigma2), 2)
round(mean(S2_3 - sigma2), 2)
round(mean(S2_4 - sigma2), 2)
# Errore quadratico medio (approssimato)
mean((S2_1 - sigma2)^2)
mean((S2_2 - sigma2)^2)
mean((S2_3 - sigma2)^2)
mean((S2_4 - sigma2)^2)
# Chunk 7
theta0 <- 40
# Numerosità campionarie
nn <- c(10, 100, 300, 500, 1000)
# Stime di massima verosimiglianza
set.seed(123)
theta_hat <- c(
max(runif(nn[1], min = 0, max = theta0)),
max(runif(nn[2], min = 0, max = theta0)),
max(runif(nn[3], min = 0, max = theta0)),
max(runif(nn[4], min = 0, max = theta0)),
max(runif(nn[5], min = 0, max = theta0))
)
theta_hat
plot(nn, theta_hat,
type = "b",
xlab = "Numerosità campionaria",
ylab = "Massima verosimiglianza"
)
par(mfrow=c(1,1))
plot(nn, theta_hat,
type = "b",
xlab = "Numerosità campionaria",
ylab = "Massima verosimiglianza"
)
1 - sum(1 /(n/2):n)
1 - sum(1 /((n/2):n))
n
n <- 100
1 - sum(1 /((n/2):n))
1 - sum(1 /((n/2 + 1):n))
R <- 1000000
set.seed(200)
Z <- replicate(R, loop_strategy(n = 100))
estimate <- mean(Z) # Stima della probabilità di successo
estimate
