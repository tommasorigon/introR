x<-runif(R)
y<-runif(R)
z<-exp(sqrt(x*y))
mean(z)
set.seed(123)
R<-10^5
i<-runif(R, 0,2)
mean(i)
sd(i)/sqrt(R)
set.seed(123)
my_integral <-function(f,g,R){
x<-dnorm(x)
valore<- f(x)/g(x)*dnorm(x)
mean(replicate(R, valore))
}
#problema3
qjb1<- function(n,R){
x<-rnorm(n)
g<-1/sd(x)^3*mean((x-mean(x))^3)
k<-1/sd(x)^4*mean((x-mean(x))^4)
jb <-n/6*(g^2+(k-3)^2/4)
replicate(R, qjb1)
}
qjb <- function(p, n, R){
quantile(qjb1(n,R), probs=p)
}
qjb(0.95, 50,1000)
library(MASS)
data("faithful")
hist(faithful$waiting)
plot(faithful$eruptions,faithful$waiting)
long_waiting<-subset(faithful, eruptions>3)
short_waiting<-subset(faithful, eruptions<=3)
plot(ecdf(long_waiting$waiting))
plot(ecdf(short_waiting$waiting), add=T ,col='red')
summary(long_waiting$waiting)
summary(short_waiting$waiting)
asym <- function(x) {
sqm <- sqrt(mean(x^2) - mean(x)^2)
mean((x - mean(x))^3) / sqm^3}
asym(long_waiting$waiting)
asym(short_waiting$waiting)
summary(long_waiting$waiting)
summary(short_waiting$waiting)
asym <- function(x) {
sqm <- sqrt(mean(x^2) - mean(x)^2)
mean((x - mean(x))^3) / sqm^3}
asym(long_waiting$waiting)
asym(short_waiting$waiting)
set.seed(123)
R<-10^5
library(MASS)
data("faithful")
hist(faithful$waiting)
plot(faithful$eruptions,faithful$waiting)
long_waiting<-subset(faithful, eruptions>3)
short_waiting<-subset(faithful, eruptions<=3)
plot(ecdf(long_waiting$waiting))
plot(ecdf(short_waiting$waiting), add=T ,col='red')
summary(long_waiting$waiting)
summary(short_waiting$waiting)
asym <- function(x) {
sqm <- sqrt(mean(x^2) - mean(x)^2)
mean((x - mean(x))^3) / sqm^3}
asym(long_waiting$waiting)
asym(short_waiting$waiting)
set.seed(123)
R<-10^5
i1<-function(R){mean(exp(sqrt(abs(rnorm(R)*rnorm(R)))))}
i2<-function(R){mean(exp(sqrt(abs(rnorm(R)))))}
i1(R)
i2(R)
#manca la densit? della normale standard da moltiplicare
my_integral<-function(f,g,R=1000){mean(f(rnorm(R) / g(rnorm(R) * dnorm(0,1))))}
qJB<-function(p,n, R=1000){camp<- replicate(R,dnorm(n,0,1))
asmp<-1/
curp<-
JB<- n/6 }
#es 1.1
R <- 10^5
x <- runif (R)
y <- runif (R)
hat1 <- mean(exp(x*y))
#es 1.2
R <- 10^5
x <- runif(R,0,2)
hat2 <- mean (exp(x))
std_error <- sd(exp(x))/sqrt(R)
hat1
asym(long_waiting)
# Problema 1 --------------------------------
# 1.1
set.seed(123)
R <- 10^6
x <- runif(R)
y <- runif(R)
mean(exp(sqrt(x * y))) # 1.601412
# Non richiesto. Verifico il risultato tramite integrazione numerica
library(cubature)
f <- function(z) exp(sqrt(z[1] * z[2]))
hcubature(f, lowerLimit = c(0, 0), upperLimit = c(1, 1))$integral # 1.60152
# 1.2
x <- runif(R, 0, 2)
# Attenzione al fatto che bisogna moltiplicare per 2 la seguente funzione, per tenere conto della costante di normalizzazione di una distribuzione uniforme in (0, 2)
g <- function(x) 2 * exp(sqrt(x))
est <- mean(g(x))
std_error <- sd(g(x)) / sqrt(R)
c(est, std_error) # 5.406536437 0.001640879
# Non richiesto. Verifico il risultato tramite integrazione numerica:
integrate(function(x) exp(sqrt(x)), lower = 0, upper = 2)
# 5.407529 with absolute error < 0.00053
# 1.3
# Le funzioni f(x) e g(x) devono essere valutate sullo stesso insieme di valori. La soluzione corretta è quindi:
my_integral <- function(f, g, R = 1000) {
x <- rnorm(R)
mean(f(x) / g(x))
}
# Problema 2 --------------------------------
library(MASS)
data(faithful)
# 2.1
hist(faithful$waiting)
plot(faithful$eruptions, faithful$waiting)
# 2.2
long_waiting <- faithful$waiting[faithful$eruptions > 3]
short_waiting <- faithful$waiting[faithful$eruptions <= 3]
# 2.3
# Quanto segue è la soluzione più elegante, che consente di confrontare le due funzioni di ripartizione
# Anche due grafici sono stati valutati positivamente (anche se di più difficile lettura)
plot(ecdf(long_waiting), xlim = c(40, 100)) # Il parametro xlim deve essere manualmente aggiustato, altrimenti il grafico risulta illeggibile
plot(ecdf(short_waiting), add = TRUE, col = "red")
# Anche calcolare mean e median separatamente era corretto
summary(long_waiting)
summary(short_waiting)
# 2.4
asym <- function(x) {
Q <- quantile(x, probs = c(0.25, 0.5, 0.75))
B <- (Q[1] + Q[3] - 2 * Q[2]) / (Q[3] - Q[1])
B
}
asym(long_waiting)
asym(short_waiting)
styler:::style_active_file()
hcubature(function(z) f_1(z[1], z[2]), lower = c(0, 0), upper = c(1, 1))
f_1 <- function(x, y) {
exp(sqrt(x * y))
}
hcubature(function(z) f_1(z[1], z[2]), lower = c(0, 0), upper = c(1, 1))
#problema 2
library(MASS)
data(faithful)
#2a
hist(faithful$waiting)
plot(faithful$eruptions,faithful$waiting)
#2b
long_waiting<-faithful$eruptions[faithful$eruptions>3]
short_waiting<-faithful$eruptions[faithful$eruptions<=3]
#2c
a<-ecdf(long_waiting)
b<-ecdf(short_waiting)
par(mfrow = c(1, 2))
plot(a)
plot(b)
median(long_waiting)
mean(long_waiting)
median(short_waiting)
mean(short_waiting)
#2d
asym<-function(x){
Q3<-quantile(x,0.75)
Q2<-quantile(x,0.5)
Q1<-quantile(x,0.25)
(Q3-2*Q2+Q1)/(Q3-Q1)
}
asym(long_waiting)
asym(short_waiting)
------------------------------------------------------------------------------
#problema 1
#1a
R<-runif(10^6)
asym(short_waiting)
R<-runif(10^6)
U<-runif(10^6)
I_1<-mean(exp(sqrt(R*U)))
I_1
#1b
I_2 <- function(R) {
U <- runif(R)*2
hU <-exp(sqrt(U))
estimate <- mean(hU)*2
std.error <- sd(hU) / sqrt(R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error")
out
}
I_2(10^6)
I_1
MonteCarloC(10^6)
qJB<-function(p,n,R1){
x<-rnorm(n)
gam<-(1/sqrt(x)^3*var(x)^3)
k<-(1/sqrt(x)^4*var(x)^4)
JB<-n/6*(gam^2+(k-3)^2/4)
}
#esercizio3
rm(list=ls())
aspearson <- function(x){
n <- length(x)
sum((x-mean(x))^3)/((n*sd(x))^3)
}
cupearson <- function(x){
n <- length(x)
sum(x-mean(x))^4/((n*sd(x))^4)
}
JB <- function(x){
n <- length(x)
((aspearson(x))^2 + ((cupearson(x)-3)^2)/4)*(n/6)
}
#3.a
qJB <- function(p, n, R=1000){
sim <- replicate(R, JB(rnorm(n)))
quantile(sim, probs=p)
}
#3.b
set.seed(001)
qJB(0.95, 50)
#1.a
set.seed(001)
x1 <- runif(10^6)
y1 <- runif(10^6)
integrale1 <- mean(mean(exp(sqrt(x1*y1))))
#la stima via simulazione viene uguale anche inserendo solo: mean(exp(sqrt(x1*y1))), messo doppio mean per completezza
integrale1
#1.b
set.seed(001)
x2 <- runif(10^6, 0, 2)
mean(exp(sqrt(x2)))
sd(mean(exp(sqrt(x2))))/sqrt(10^6)
#esercizio2
rm(list=ls())
library(MASS)
data(faithful)
#2.a
hist(faithful$waiting)
plot(faithful$eruptions, faithful$waiting)
#2.b
long_waiting <- faithful$waiting[faithful$eruptions>3]
#esercizio1
rm(list=ls())
#1.a
set.seed(001)
x1 <- runif(10^6)
y1 <- runif(10^6)
integrale1 <- mean(mean(exp(sqrt(x1*y1))))
#la stima via simulazione viene uguale anche inserendo solo: mean(exp(sqrt(x1*y1))), messo doppio mean per completezza
integrale1
#1.b
set.seed(001)
x2 <- runif(10^6, 0, 2)
mean(exp(sqrt(x2)))
sd(mean(exp(sqrt(x2))))/sqrt(10^6)
#esercizio3
rm(list=ls())
aspearson <- function(x){
n <- length(x)
sum((x-mean(x))^3)/((n*sd(x))^3)
}
cupearson <- function(x){
n <- length(x)
sum(x-mean(x))^4/((n*sd(x))^4)
}
cupearson <- function(x){
n <- length(x)
sum((x-mean(x))^4)/((n*sd(x))^4)
}
JB <- function(x){
n <- length(x)
((aspearson(x))^2 + ((cupearson(x)-3)^2)/4)*(n/6)
}
#3.a
qJB <- function(p, n, R=1000){
sim <- replicate(R, JB(rnorm(n)))
quantile(sim, probs=p)
}
#3.b
set.seed(001)
qJB(0.95, 50)
set.seed(001)
qJB(0.95, 50)
set.seed(001)
qJB(0.95, 50)
set.seed(001)
qJB(0.95, 50)
set.seed(001)
qJB(0.95, 50)
aspearson(rnorm(100))
aspearson(rnorm(100))
aspearson(rnorm(100))
aspearson(rxp(100))
aspearson(rexp(100))
aspearson(rexp(100))
aspearson(rexp(100))
aspearson(rexp(100))
#esercizio3
rm(list=ls())
aspearson <- function(x){
n <- length(x)
mean((x-mean(x))^3)/((n*sd(x))^3)
}
cupearson <- function(x){
n <- length(x)
mean((x-mean(x))^4)/(sd(x)^4))
JB <- function(x){
n <- length(x)
((aspearson(x))^2 + ((cupearson(x)-3)^2)/4)*(n/6)
}
aspearson <- function(x){
n <- length(x)
mean((x-mean(x))^3)/(n*sd(x))^3)
cupearson <- function(x){
n <- length(x)
mean((x-mean(x))^4)/(sd(x)^4)
}
aspearson <- function(x){
n <- length(x)
mean((x-mean(x))^3)/sd(x)^3
}
cupearson <- function(x){
n <- length(x)
mean((x-mean(x))^4)/sd(x)^4
}
JB <- function(x){
n <- length(x)
((aspearson(x))^2 + ((cupearson(x)-3)^2)/4)*(n/6)
}
aspearson(rexp(100))
#3.a
qJB <- function(p, n, R=1000){
sim <- replicate(R, JB(rnorm(n)))
quantile(sim, probs=p)
}
#3.b
set.seed(001)
qJB(0.95, 50)
#esercizio2
rm(list=ls())
library(MASS)
data(faithful)
#2.a
hist(faithful$waiting)
plot(faithful$eruptions, faithful$waiting)
#2.b
long_waiting <- faithful$waiting[faithful$eruptions>3]
short_waiting <- faithful$waiting[faithful$eruptions<=3]
#2.c
plot(ecdf(long_waiting),
do.points= TRUE, col='black',
main = "NERO: eruzioni lunghe, ROSSO: eruzioni brevi",)
plot(ecdf(short_waiting), col='red', add=TRUE)
mean(long_waiting)
median(long_waiting)
mean(short_waiting)
median(short_waiting)
#nel grafico precedente non veniva completo perch? troppo grande la scala li ho messi divisi
par(mfrow = c(1, 1))
plot(ecdf(long_waiting))
plot(ecdf(short_waiting))
#nel grafico precedente non veniva completo perch? troppo grande la scala li ho messi divisi
par(mfrow = c(1, 2))
plot(ecdf(long_waiting))
plot(ecdf(short_waiting))
#2.d
asym <- function(x){
num <- quantile(x , probs=0.75) - 2*quantile(x, probs=0.5) + quantile(x, probs=0.25)
den <- quantile(x , probs=0.75) - quantile(x, probs=0.25)
num/den
}
asym(long_waiting)
asym(short_waiting)
#esercizio3
rm(list=ls())
aspearson <- function(x){
n <- length(x)
sum((x-mean(x))^3)/((n*sd(x))^3)
}
cupearson <- function(x){
n <- length(x)
sum(x-mean(x))^4/((n*sd(x))^4)
}
JB <- function(x){
n <- length(x)
((aspearson(x))^2 + ((cupearson(x)-3)^2)/4)*(n/6)
}
aspearson(rnorm(100))
#esercizio3
rm(list=ls())
aspearson <- function(x){
n <- length(x)
mean((x-mean(x))^3)/sd(x)^3
}
aspearson(rnorm(100))
cupearson <- function(x){
n <- length(x)
sum((x-mean(x))^4)/ (n *sd(x)^4)
}
#appello 20/02/2023, Nicole Gemelli, matricola 880002
#esercizio 1
#a
set.seed(123)
R<-10^2
#utilizzando le propriet? degli integrali doppi posso calcolare le variabili x ed y separatamente,in quanto le due variabili non sono dipendenti tra di loro, e moltiplicarle successivamente
f<-function(x){
x<-runif(R)
exp(sqrt(x))
}
g<-function(y){
y<-runif(R)
exp(sqrt(y))
}
a<-mean(f(R))
b<-mean(g(R))
a*b
# 1.2
x <- runif(R, 0, 2)
# Attenzione al fatto che bisogna moltiplicare per 2 la seguente funzione, per tenere conto della costante di normalizzazione di una distribuzione uniforme in (0, 2)
g <- function(x) 2 * exp(sqrt(x))
est <- mean(g(x))
std_error <- sd(g(x)) / sqrt(R)
c(est, std_error) # 5.406536437 0.001640879
#esercizio 2
library(MASS)
data("faithful")
#a
hist(faithful$waiting,main="istogramma variabile waiting")
plot(faithful$eruptions,faithful$waiting,xlab="variabile eruptions",ylab="variabile waiting")
#b
long_waiting<-faithful$waiting[faithful$eruptions >3]
short_waiting<-faithful$waiting[faithful$eruptions<=3]
#c
par(mfrow=c(1,3))
plot(ecdf(long_waiting),main="grafico funzione di ripetizione empirica variabile long_waiting",col="purple")
plot(ecdf(short_waiting),main="grafico funzione di ripetizione empirica variabile short_waiting",col="pink")
plot(ecdf(long_waiting),main="confronto:funzione empirica long_waiting in viola,short_waiting in rosa", col="purple")
lines(ecdf(short_waiting),col="pink")
#c
par(mfrow=c(1,2))
plot(ecdf(long_waiting),main="grafico funzione di ripetizione empirica variabile long_waiting",col="purple")
plot(ecdf(short_waiting),main="grafico funzione di ripetizione empirica variabile short_waiting",col="pink")
par(mfrow = c(1,1))
plot(ecdf(long_waiting),main="confronto:funzione empirica long_waiting in viola,short_waiting in rosa", col="purple")
plot(ecdf(long_waiting),main="confronto:funzione empirica long_waiting in viola,short_waiting in rosa", col="purple")
lines(ecdf(short_waiting),col="pink")
plot(ecdf(long_waiting),main="confronto:funzione empirica long_waiting in viola,short_waiting in rosa", col="purple", xlim = c(40,  100))
lines(ecdf(short_waiting),col="pink")
summary(long_waiting)
summary(short_waiting)
#d
asym<-function(x){
q0.75<-quantile(x,probs = 0.75)
q0.25<-quantile(x,probs=0.25)
q0.5<-quantile(x,probs=0.5)
(q0.75-2*q0.5+q0.25)/(q0.75-q0.25)
}
asym(long_waiting)
asym(short_waiting)
#esercizio 3
asymp<-function(x){
sqm<- sd(x)
mean((x-mean(x))^3)/sqm^3
}
curtp<-function(x){
sqm<-sd(x)
mean((x-mean(x))^4)/sqm^4
}
#esercizio 3
asymp<-function(x){
sqm<- sd(x)
mean((x-mean(x))^3)/sqm^3
}
curtp<-function(x){
sqm<-sd(x)
mean((x-mean(x))^4)/sqm^4
}
qJB<-function(p,n,R=1000){
x<-rnorm(R)
p<-quantile(x,probs=p)
(n/6) *((asymp(x)^2)+((curtp(x)-3)^2)/4)
}
set.seed(123)
R<-1000
n<-10
X<-replicate(R,rnorm(n))
p<-0.25
qJB(p,n,R)
p<-0.5
qJB(p,n,R)
p<-0.75
qJB(p,n,R)
asympt(rnorm(1000))
asymp(rnorm(1000))
asymp(rnorm(1000))
asymp(rnorm(1000))
asymp(rnorm(1000))
curtp(rnorm(1000))
curtp(rnorm(1000))
curtp(rnorm(1000))
curtp(rnorm(1000))
JB <- function(x){
n <- length(x)
(n/6) *((asymp(x)^2)+((curtp(x)-3)^2)/4)
}
JB(c(10,20,1, 1,1,1,1,5, 7))
