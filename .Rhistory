y<- c(0,0,0,0,0,0,0,0)
curve(loglik(x,y),0,5)
theta_hat2<- nlminb(start = 1, objective = function(theta) - loglik(theta, y), lower = 1e-5)
th2<-theta_hat2$par
loglik_approx<- function(theta,y){
loglik(th2,y)-(length(y)/(2*th2))*(theta-th2)^2
}
curve(loglik_approx(x,y),0,5,add=T,col="red")
#Problema 1
#a
R<-10^6
x <- rexp(R)
I<-((1/x)*exp(-x))
estimate<-mean(I)
std.error <- sd(I) / sqrt(R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error")
out
#b
R<-10^6
x <- runif(R)
y <- runif(R)
I2<-exp(-((x+y)^2))
estimate2<-mean(I2)
estimate2
#Problema 2
#a
rmistery<-function(R, lambda){
U<-runif(R)
x<--(1/lambda)*log(U)
x
}
#b
mean(rmistery(10^6, 2))
var(rmistery(10^6, 2))
#c
std.error<-sd(rmistery(10^6, 2))/sqrt(10^6)
std.error
#d
mean(rmistery(10^6, 1)<=2.4)
#e
hist(rmistery(10^6, 1), freq = FALSE, breaks=50)
curve(dexp(x), add = TRUE, col = "red")
#Problema 3
#a
loglik <- function(theta, y) {
-(length(y) * theta) + log(theta) * sum(y)
}
#b
y<-c(2, 4, 1, 6, 9, 3, 1, 1)
curve(loglik(x, y), 0, 15)
#c
fit<- nlminb(start = 0, objective = function(theta) - loglik(theta, y), lower = 1e-5)
fit$par
#d
loglik_approx <- function(theta, y) {
theta_approx<-mean(y)
loglik(theta_approx, y) - (length(y)/2*(theta_approx))*(theta-theta_approx)^2
}
curve(loglik(x, y), 3, 4)
curve(loglik_approx(x, y), add = TRUE, col = "red", 3, 4)
#d
loglik_approx <- function(theta, y) {
theta_approx<-mean(y)
loglik(theta_approx, y) - (length(y)/(2*(theta_approx))*(theta-theta_approx)^2)
}
curve(loglik(x, y), 3, 4)
curve(loglik_approx(x, y), add = TRUE, col = "red", 3, 4)
#e
k<-c(0, 0, 0, 0, 0, 0, 0, 0)
curve(loglik(x, k), 0, 5)
fit<- nlminb(start = 0, objective = function(theta) - loglik(theta, k), lower = 1e-5)
fit$par
curve(loglik(x, k)^2, 0, 5)
#Problema 3
#a
loglik <- function(theta, y) {
-(length(y) * theta) + log(theta) * sum(y)
}
#b
y<-c(2, 4, 1, 6, 9, 3, 1, 1)
curve(loglik(x, y), 0, 15)
#c
fit<- nlminb(start = 0, objective = function(theta) - loglik(theta, y), lower = 1e-5)
fit$par
#d
loglik_approx <- function(theta, y) {
theta_approx<-mean(y)
loglik(theta_approx, y) - (length(y)/(2*(theta_approx))*(theta-theta_approx)^2)
}
curve(loglik(x, y), 3, 4)
curve(loglik_approx(x, y), add = TRUE, col = "red", 3, 4)
#e
k<-c(0, 0, 0, 0, 0, 0, 0, 0)
curve(loglik(x, k), 0, 5)
fit<- nlminb(start = 0, objective = function(theta) - loglik(theta, k), lower = 1e-5)
fit$par
curve(loglik(x, k)^2, 0, 5)
#problema 1
#a
R<-10^5
x<-runif(R)
int<-(1/x)*exp(-x)
mean(int)
sd(int)/sqrt(R)
#b
x<-runif(R)
y<-runif(R)
mean(exp(-(x+y)^2))
#c
#la risposta non ? corretta perch? le funzioni f(x) e g(x) devono essere valutate sullo stesso insieme di dati
my_integral<-function(f,g,R=1000){
x<-rnorm(R)
mean(f(x)/g(x))
}
#problema 2
#a
rmistery<-function(R,lambda){
u<-runif(R)
-(1/lambda)*log(u)
}
#b
R<-10^5
lambda<-2
x<-rmistery(R,lambda)
mean(x)
var(x)
#c
sd(x)/sqrt(R)
#d
lambda<-1
X<-rmistery(R,lambda)
mean(X<=2.4)
#e
par(mfrow=c(1,1))
hist(X, freq=F)
#problema 3
#a
loglik<-function(theta,y){
n<-length(y)
-n*theta+log(theta)*sum(y)
}
#b
y<-c(2,4,1,6,9,3,1,1)
curve(loglik(x,y),from = 0,to=15)
#c
nlminb(start=0.5,objective = function(theta)-loglik(theta,y), lower = 0, upper = Inf)$par
#d
loglik_approx<-function(theta,y){
th<-mean(y)
n<-length(y)
loglik(th,y)-n/(2*th)*(theta-th)^2
}
par(mfrow=c(1,2))
curve(loglik(x,y),from=3,to=4, ylab="loglik")
curve(loglik_approx(x,y),from = 3, to=4, ylab="loglik_approx")
#e
Y<-c(0,0,0,0,0,0,0,0)
curve(loglik(x,Y),from = 0, to=5)
nlminb(start=0, objective=function(theta)-loglik(theta,Y))$par
#problema 1
#a
R<-10^5
x<-runif(R)
int<-(1/x)*exp(-x)
mean(int)
sd(int)/sqrt(R)
#b
x<-runif(R)
y<-runif(R)
mean(exp(-(x+y)^2))
#c
#la risposta non ? corretta perch? le funzioni f(x) e g(x) devono essere valutate sullo stesso insieme di dati
my_integral<-function(f,g,R=1000){
x<-rnorm(R)
mean(f(x)/g(x))
}
#problema 2
#a
rmistery<-function(R,lambda){
u<-runif(R)
-(1/lambda)*log(u)
}
#b
R<-10^5
lambda<-2
x<-rmistery(R,lambda)
mean(x)
var(x)
#c
sd(x)/sqrt(R)
#problema 1
# a
R<-10^5
x<-runif(R)
int<-(1/x)*exp(-x)
mean(int)
sd(int)/sqrt(R)
#b
x<-runif(R)
y<-runif(R)
mean(exp(-(x+y)^2))
#problema 2
#a
rmistery<-function(R,lambda){
u<-runif(R)
-(1/lambda)*log(u)
}
#b
R<-10^5
lambda<-2
x<-rmistery(R,lambda)
mean(x)
var(x)
#c
sd(x)/sqrt(R)
#d
lambda<-1
X<-rmistery(R,lambda)
mean(X<=2.4)
#e
par(mfrow=c(1,1))
hist(X, freq=F)
#problema 3
#a
loglik<-function(theta,y){
n<-length(y)
-n*theta+log(theta)*sum(y)
}
#b
y<-c(2,4,1,6,9,3,1,1)
curve(loglik(x,y),from = 0,to=15)
#c
nlminb(start=0.5,objective = function(theta)-loglik(theta,y), lower = 0, upper = Inf)$par
#d
loglik_approx<-function(theta,y){
th<-mean(y)
n<-length(y)
loglik(th,y)-n/(2*th)*(theta-th)^2
}
par(mfrow=c(1,2))
curve(loglik(x,y),from=3,to=4, ylab="loglik")
curve(loglik_approx(x,y),from = 3, to=4, ylab="loglik_approx")
curve(loglik(x,y),from=3,to=4, ylab="loglik")
curve(loglik_approx(x,y),from = 3, to=4, ylab="loglik_approx", add = TRUE)
#e
Y<-c(0,0,0,0,0,0,0,0)
curve(loglik(x,Y),from = 0, to=5)
nlminb(start=0, objective=function(theta)-loglik(theta,Y))$par
rm(list=ls())
set.seed(123)
R <- 10^6
x <- rnorm(R)
mean((1 / x) * exp(-x))
hist(x)
set.seed(123)
R <- 10^6
x <- rnorm(R)
y <- rnorm(R)
mean(exp(-(x + y)^2))
rm(list=ls())
rmistery <- function(R, lambda) {
U <- runif(R , 0 , 1)
(-(1 / lambda)) * log(U)
}
set.seed(123)
R <- 10^6
lambda <- 2
mean(rmistery(R , lambda))
var(rmistery(R , lambda))
set.seed(123)
R <- 10^6
sd(rmistery(R , lambda) / sqrt(R))
sd
set.seed(123)
R <- 10^6
lambda <- 1
mean(rmistery(R , lambda) == 2)
mean(rmistery(R , lambda) == 4)
loglik <- function(theta , y) {
n <- length(y)
-(n * theta) + (log(theta) * sum(y))
}
y <- c(2 , 4 , 1 , 6 , 9 , 3 , 1 , 1)
curve(loglik(x , y) , 0 , 15)
vero <- nlminb(start = 1 , objective = function(theta) - loglik(theta , y) , lower = 1e-5)
vero
lambda_hat <- vero$par
lambda_hat
loglik_hat <- function(y) {
n <- length(y)
theta_hat <- mean(y)
-(n * theta_hat) + (log(theta_hat) * sum(y))
}
loglik_hat(y)
loglik_approx <- function(theta , y) {
n <- length(y)
theta_hat <- mean(y)
loglik_hat(y) - ((n / 2 * theta_hat) *((theta - theta_hat)^2))
}
par(mfrow = c(1 , 2))
curve(loglik(x , y) , 3 , 4)
curve(loglik_approx(x , y) , 3 , 4)
par(mfrow = c(1 , 1))
y <- c(0 , 0 , 0 , 0 , 0 , 0 , 0 , 0)
curve(loglik(x , y) , 0 , 5)
vero <- nlminb(start = 1 , objective = function(theta) - loglik(theta , y) , lower = 1e-5)
vero
lambda_hat <- vero$par
lambda_hat
vero
lambda_hat <- vero$par
lambda_hat
# a _____________________________________
loglik1 <- function(theta, y) {
length(y) * theta + log(theta) * sum(y)
}
# b ____________________________________
x <- c(2,4,1,6,9,3,1,1)
y <- dpois(x, lambda = 1)
loglik1(x,y)
curve(loglik1(x,y), 0,15)
# c _____________________________________
max_ver <- nlminb(start = 1, objective = function(theta) - loglik1(theta, y), lower = 1e-5)
# d _____________________________________
theta_hat <- max_ver$par
theta_hat
loglik_approx <- function(theta,y) {
loglik1 - (length(y)/2*theta_hat ) * (theta - theta_hat)^2
}
par(mfrow = c(1, 2))
curve(loglik1(x, y), 3,4)
curve(loglik_approx(x,y), 3,4)
abline(v = theta_hat)
# a _____________________________________
loglik1 <- function(theta, y) {
length(y) * theta + log(theta) * sum(y)
}
# b ____________________________________
x <- c(2,4,1,6,9,3,1,1)
y <- dpois(x, lambda = 1)
loglik1(x,y)
# a _____________________________________
loglik1 <- function(theta, y) {
length(y) * theta + log(theta) * sum(y)
}
# b ____________________________________
x <- c(2,4,1,6,9,3,1,1)
y <- dpois(x, lambda = 1)
loglik1(x,y)
curve(loglik1(x,y), 0,15)
# c _____________________________________
max_ver <- nlminb(start = 1, objective = function(theta) - loglik1(theta, y), lower = 1e-5)
# d _____________________________________
theta_hat <- max_ver$par
theta_hat
loglik_approx <- function(theta,y) {
loglik1 - (length(y)/2*theta_hat ) * (theta - theta_hat)^2
}
par(mfrow = c(1, 2))
curve(loglik1(x, y), 3,4)
curve(loglik_approx(x,y), 3,4)
abline(v = theta_hat)
# e _________________________________
t <-c(0,0,0,0,0,0,0,0)
y <- dpois(t, lambda = 1)
curve(loglik1(x,y), 0,5)
app_q <- c(exp(theta_hat), theta_hat)
app_q
#  2 ____________________________________________
#a
R <- 5000
set.seed(123)
U <- runif(R, 0, 1)
Y <- function(l) {
(-1/l)*log(U)
}
Y
#b
MonteCarlo <- function(R) {
U
Y(2)
estimate <- mean(U)
std.error <- sd(U) / sqrt(R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error")
out
}
MonteCarlo(5000)
#e
hist(MonteCarlo(5000), freq = FALSE, breaks = 100)
curve(MonteCarlo(5000), add = TRUE)
#1
#a
R<-10^5
x<-rexp(R)
mean(x)
sd(x)/sqrt(R)
#b
x<-runif(R)
y<-runif(R)
mean(exp(-(x+y)^2))
#c
#la risposta non ? corretta poich? la funzione campiona da 2 diverse normali
#soluzione
my_integral<-function(f,g,R=1000){
X<-rnorm(R)
mean(f(X)/g(X))
}
#2
#a
rmistery<-function(R,lambda){
-1/lambda*log(runif(R))
}
#b
mean(rmistery(R,2))
var(rmistery(R,2))
#c
sd(rmistery(R,2))/sqrt(R)
#d
mean(rmistery(R,1)<=2.4)
#e
hist(rmistery(R,1),freq=F,breaks=100)
curve(dexp(x,1),add=T)
#3
#a
loglik<-function(theta,y){
n<-length(y)
-n*theta+log(theta)*sum(y)
}
#b
y<-c(2,4,1,6,9,3,1,1)
curve(loglik(x,y),0,15)
#c
fit<-nlminb(start=1,objective=function(theta)-loglik(theta,y),lower=1e-5)
theta_hat<-fit$par
#d
loglik_approx<-function(theta,y){
theta_hat<-mean(y)
n<-length(y)
loglik(theta_hat,y)-(n/(2*theta_hat))*(theta-theta_hat)^2
}
curve(loglik(x,y),3,4)
curve(loglik_approx(x,y),3,4,add=T,col="red")
#e
y1<-c(0,0,0,0,0,0,0,0)
curve(loglik(x,y1),0,5)
fit1<-nlminb(start=0.05,objective=function(theta)-loglik(theta,y1),lower=1e-5)
theta_hat1<-fit1$par
curve(loglik_approx(x,y1))
#
set.seed(396)
R = 10^6
vett = rexp(R, 1)
int = mean(1/vett)
prec = sd(1/vett) / sqrt(R)
c(int, prec)
f = function(x){
1/x * exp(-x)
}
set.seed(396)
x = runif(R)
y = runif(R)
mean(exp(-(x+y)^2))
my_integral = function(f, g, R = 1000){
x = rnorm(R)
mean(f(x)/g(x))
}
#la soluzione presente nel tema di esame non ? corretta perch? in
#quel modo le funzioni f e g vengono applicate a vettori diversi.
#invece devono essere applicate allo stesso vettore
rm(list = ls())
set.seed(396)
rmistery = function(R, lambda){
(-1) / lambda * log(runif(R))
}
R = 10^5
x = rmistery(R, 2)
media = mean(x)
var = mean( (x - media)^2)
c(media, var)
errm = sd(x) / sqrt(R)
errv = sd((x-media)^2) / sqrt(R)
c(errm, errv)
set.seed(396)
mean(rmistery(R, 1) < 2.4)
hist(rmistery(R, 1), breaks = 100, freq = FALSE)
curve(dexp(x, 1), add = TRUE)
#3
rm(list = ls())
loglik = function(theta, y){
n = length(y)
((-n)*theta) + log(theta) * sum(y)
}
y = c(2,4,1,6,9,3,1,1)
curve(loglik(x, y), from = 0, to = 15)
stima = nlminb(start = 0.5, objective = function(theta) -loglik(theta, y))
stima
maxver = stima$par
abline(v = maxver)
loglik_approx = function(theta, y){
return(loglik(theta, mean(y)) - length(y) / (2*mean(y)) * (theta -mean(y))^2)
}
par(mfrow = c(1, 2))
curve(loglik(x, y), from = 3, to = 4)
curve(loglik_approx(x, y), from = 3, to = 4, col = 'red')
par(mfrow = c(1,1))
y = c(0, 0, 0, 0, 0, 0, 0, 0)
length(y)
curve(loglik(x, y), from = 0, to = 5)
#curve(loglik(x, y), from = 0, to = 1e-5)
stima1 = nlminb(start = 0.0001, objective = function(theta) -loglik(theta, y))
