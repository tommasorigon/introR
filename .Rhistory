#1.b
d_cop<- c(subset(D, select=c(Copenhagen)))
d_cop<- d_cop[-c(7)]
d_cop
#1.c
sort(d_cop, decreasing = T)
which.min(d_cop) #Hook of Holland
which.max(d_cop) #Athens
#1.d
sort(D, decreasing=F)[22:30]
sort(D, decreasing = T)[1:25]
#1.e
mean(D-diag(D)) #1433.474
#1.f
sigma2<- ((sum(D))^2)/(2*(21^2))
sigma2
#1.f
sigma2<- ((sum(D))^2)/(2*(21^2))
sigma2
sqrt(sigma2)
#2.a
H<- function(n, alpha){
sum(1/((1:n)^alpha))
}
H(10,1) #2.928
#2.b
dzipf<- function(k,n, alpha){
(k^(-alpha))/H(n, alpha)
}
dzipf(5, 10, 2) #0.0258
#2.c
curve(dzipf(x, 50, 1), type='h')
#2.d
1- sum(dzipf(10, 100, 2)) #0.994
#2.e
set.seed(123)
R <- 10^5
rzipf<- function(R, n, alpha){
replicate(R, sum(sample(dzipf(k,n,alpha), size=R)))
}
#2.f
mean(rzipf(R, 50, 1))
#3.1
T1<- function(y){
exp(-(mean(y)))
}
T2<- function(y){
mean(y==0)
}
#3.a
lambda<-3
psi<- dpois(0, lambda)
nn<-c(10, 100, 500, 1000, 5000, 10000)
set.seed(123)
T1_seq<- c(
T1(rpois(nn[1], lambda)),
T1(rpois(nn[2], lambda)),
T1(rpois(nn[3], lambda)),
T1(rpois(nn[4], lambda)),
T1(rpois(nn[5], lambda)),
T1(rpois(nn[6], lambda))
)
T2_seq<- c(
T2(rpois(nn[1], lambda)),
T2(rpois(nn[2], lambda)),
T2(rpois(nn[3], lambda)),
T2(rpois(nn[4], lambda)),
T2(rpois(nn[5], lambda)),
T2(rpois(nn[6], lambda))
)
plot(nn, T1_seq, type='b')
abline(h=psi, lty='dotted')
plot(nn, T2_seq, type='b')
abline(h=psi, lty='dotted')
#3.b-c
set.seed(123)
R<-10^6
n<-20
psi1<-dpois(0, lambda)
T1_sim<- replicate(R, T1(rpois(n=n, lambda)))
T2_sim<- replicate(R, T2(rpois(n=n, lambda)))
#distorsioni
round(mean(T1_sim- psi1), 4) #0.0038
round(mean(T2_sim- psi1), 4) #0
#errore quadratico medio
mean((T1_sim-psi1)^2) #0.0004
mean((T2_sim-psi1)^2) #0.002
data(eurodist)
#1.a
D <- as.matrix(eurodist)
D_sub <- matrix(c(0, 856, 586, 856, 0, 1476, 586, 1476, 0), nrow = 3, ncol = 3, dimnames = list(c("Milan", "Paris", "Rome"), c("Milan", "Paris", "Rome")))
D_sub[3,2]
D_sub
distanze <- c(D[7, 1:21])
distances <- function(distanze) {
n <- length(x) # Ottengo la lunghezza del vettore x
D <- matrix(0, nrow = n, ncol = n) # Creazione matrice vuota
for (i in 1:n) {
for (j in 1:n) {
D[i, j] <- (x[i] - x[j])^2
}
}
D # Valore da restituire
}
#2.a
H <- function(n, alpha) {
k <- 1:n
sum(1 / (k^alpha))
}
H(10, 1)
dzipf <-function(k, n, alpha) {
k <- 1:n
(k^(-alpha)) /( sum(1 / (k^alpha)))   #so che si poteva vettorizzare H tramite numeric ma non ricordo la sintassi
}
dzipf(5, 10, 2)
plot(dzipf(k, 50, 1), type = "h")
R <- 10^5
r_zipf <- sample(R, size = n, replace = TRUE)
r_zipf
R <- 10^5
n <- 20
T1 <- function(y) {
exp(-mean(y))
}
T2 <- function(y) {
sum(y=0) / n
}
T1_sim <- replicate(R, T1(rpois(n = 20, lambda = 3)))
T2_sim <- replicate(R, T2(rpois(n=20, lambda = 3)))
round(mean(T1_sim - lambda), 2)
round(mean(T2_sim - lambda), 2)
n <- 20
lambda <- 3
mean((T1_sim - lambda)^2)
mean((T2_sim - lambda)^2)
# Esercizio 1
# a
rm(list = ls())
data(eurodist)
D <- as.matrix(eurodist)
D_sub <- D[c(16,18,19),c(16,18,19)]
D_sub[3,2] # distanza tra Roma e Parigi
#b
D_cop <- matrix(D[7,])
rownames(D_cop) <- rownames(D)
colnames(D_cop) <- c("Copenhagen")
# tolgo la distanza tra Copenhagen e se stessa
D_cop <- D_cop[-7,]
#c
sort(D_cop, decreasing = T)[1] # distanza massima da copenhagen
sort(D_cop, decreasing = F)[2] # distanza minima da copenhagen
#d
val_max <- max(D[,])
which(D[,] == val_max)
#e
# ordino la matrice ed elimino i primi n valori che corrispondono agli n zeri della diagonale
D_sort <- sort(D)
D_sort <- D_sort[-(1:n)]
# media
mean(D_sort)
#f
n <-nrow(D)
#e
# ordino la matrice ed elimino i primi n valori che corrispondono agli n zeri della diagonale
D_sort <- sort(D)
D_sort
D_sort <- D_sort[-(1:n)]
# media
mean(D_sort)
#f
n <-nrow(D)
sigma2 <- sum((D[1:n, 1:n])^2)/(2 * n^2)
sigma2
#c
sort(D_cop, decreasing = T)[1] # distanza massima da copenhagen
sort(D_cop, decreasing = F)[2] # distanza minima da copenhagen
#b
D_cop <- matrix(D[7,])
rownames(D_cop) <- rownames(D)
colnames(D_cop) <- c("Copenhagen")
# tolgo la distanza tra Copenhagen e se stessa
D_cop <- D_cop[-7,]
#c
sort(D_cop, decreasing = T)[1] # distanza massima da copenhagen
sort(D_cop, decreasing = F)[2] # distanza minima da copenhagen
sort(D_cop, decreasing = F)
# Esercizio 2
rm(list = ls())
#a
H <- function(n, alpha) {
sum(1/(1:n)^alpha)
}
H(10, 1)
# b
dzipf <- function(k, n, alpha) {
k^(-alpha)/H(n, alpha)
}
dzipf(5, 10, 2)
#c
alpha <- 1
n <- 50
curve(dzipf(x, n, alpha), type = "h")
# d
alpha <- 2
n <- 100
1 - sum(dzipf(1:9, 100, 2))
# e
rzipf <- function(R, n, alpha) {
replicate(R, sample(dzipf(1:n, n, alpha)))
}
#f
set.seed(123)
1 - sum(dzipf(1:9, 100, 2))
#f
set.seed(123)
R <- 10^5
n <- 50
alpha <- 1
sim <- rzipf(R, n, alpha)
mean(sim)
# Esercizio 3
rm(list = ls())
T1 <- function(y) exp(-mean(y))
T2 <- function(y) mean(y == 0)
#a
lambda <- 3
nn <- c(50, 500, 5000, 50000, 100000)
set.seed(123)
T1_seq <- c(
(T1(rpois(nn[1], lambda))),
(T1(rpois(nn[2], lambda))),
(T1(rpois(nn[3], lambda))),
(T1(rpois(nn[4], lambda))),
(T1(rpois(nn[5], lambda)))
)
T1_seq
T2_seq <- c(
(T2(rpois(nn[1], lambda))),
(T2(rpois(nn[2], lambda))),
(T2(rpois(nn[3], lambda))),
(T2(rpois(nn[4], lambda))),
(T2(rpois(nn[5], lambda)))
)
T2_seq
#b
set.seed(156)
n <- 20
R <- 10^5
sim1 <- replicate(R, T1(rpois(n, lambda)))
mean(sim)
mean(sim1)
sim2 <- replicate(R, T2(rpois(n, lambda)))
mean(sim2)
# Distorsione
sd(sim1) / sqrt(R)
sd(sim2) / sqrt(R)
# c
# errore quadratico medio
(sd(sim1) / sqrt(R))^2
(sd(sim2) / sqrt(R))^2
# Esercizio 3
rm(list = ls())
T1 <- function(y) exp(-mean(y))
T2 <- function(y) mean(y == 0)
#a
lambda <- 3
nn <- c(50, 500, 5000, 50000, 100000)
set.seed(123)
T1_seq <- c(
(T1(rpois(nn[1], lambda))),
(T1(rpois(nn[2], lambda))),
(T1(rpois(nn[3], lambda))),
(T1(rpois(nn[4], lambda))),
(T1(rpois(nn[5], lambda)))
)
T1_seq
T2_seq <- c(
(T2(rpois(nn[1], lambda))),
(T2(rpois(nn[2], lambda))),
(T2(rpois(nn[3], lambda))),
(T2(rpois(nn[4], lambda))),
(T2(rpois(nn[5], lambda)))
)
T2_seq
data("eurodist")
D <- as.matrix(eurodist)
head(D)
1.1
D_sub <- matrix(c(D[16,16], D[16,18], D[16,19], D[18,16], D[18,18], D[18,19], D[19,16], D[19,18], D[19,19]), nrow=3, ncol=3)
# la distanza tra Roma e Parigi ? 1476 km D[18,19]
1.2
d_cop <- rbind(c(D[7, 1:6],D[7,8:21]))
1.3
sort(d_cop)
which.min(d_cop)
which.max(d_cop)
# la pi? vicina ? Hook of Holland
# la pi? lontana ? Atene
1.4
sort(D, decreasing=FALSE)
sort(D, decreasing=TRUE)
1.5
sum <- 0
for (i in 1:21) {
for (j in 1:21) {
sum <- sum + D[i,j]
}
}
media <- sum/(21*21-21)
media
varcitta1 <- 0
for (i in 1:n) {
for (j in 1:n) {
varcitta1 <- varcitta1 + (D[i,j])^2
}
}
varcitta <- varcitta1/(2*(n)^2)
n <- 21
for (i in 1:n) {
for (j in 1:n) {
varcitta1 <- varcitta1 + (D[i,j])^2
}
}
varcitta <- varcitta1/(2*(n)^2)
varcitta
H <- function(n, alpha) {
sum(1/(1:n)^alpha)
}
H(10,1) # vale 2.928968
dzipf <- function(k,n,alpha) {
(k^(-alpha))/(H(n,alpha))
}
dzipf(5,10,2) # vale 0.02581032
curve(dzipf(x,50,1), type="h")
p <- 1-(sum(dzipf(1:9,100,2)))
rzipf1 <- function(n,alpha) {
sample(dzipf(1:n,n,alpha))
}
rzipf <- function(R,n,alpha) {
replicate(R,rzipf1(n,alpha))
}
T1 <- function(x) {
exp(-mean(x))
}
T2 <- function(x){
mean(x == 0)
}
lambda <- 3
nn <- c(100,200,400,1000)
set.seed(100)
plot(T1(rpois(nn[1], lambda)),nn[1])
plot(T1(rpois(nn[2], lambda)),nn[2], add=TRUE)
plot(T1(rpois(nn[3], lambda)),nn[3], add=TRUE)
plot(T1(rpois(nn[4], lambda)),nn[4], add=TRUE)
T1 <- function(x) {
exp(-mean(x))
}
T2 <- function(x){
mean(x == 0)
}
lambda <- 3
nn <- c(100,200,400,1000)
set.seed(100)
plot(T1(rpois(nn[1], lambda)),nn[1])
plot(T1(rpois(nn[2], lambda)),nn[2], add=TRUE)
plot(T1(rpois(nn[3], lambda)),nn[3], add=TRUE)
plot(T1(rpois(nn[4], lambda)),nn[4], add=TRUE)
plot(T2(rpois(nn[1], lambda)),nn[1])
plot(T2(rpois(nn[2], lambda)),nn[2], add=TRUE)
plot(T2(rpois(nn[3], lambda)),nn[3], add=TRUE)
plot(T2(rpois(nn[4], lambda)),nn[4], add=TRUE)
phi0 <- dpois(0,lambda)
3.2
set.seed(100)
n2 <- 20
sim <- replicate(R, rpois(n2,lambda))
mean(T1(sim)-phi0) # vale circa 0
mean(T2(sim)-phi0) # vale circa 0
3.3
mean((T2(sim)-phi0)^2) # vale circa 2
mean((T1(sim)-phi0)^2) # vale circa 10
data(eurodist)
n <- 21
D <- as.matrix(eurodist)
is.numeric(D)
#a
D_sub <- subset(D, select = c (Milan, Paris, Rome)) #dovrei selezionare anche le righe
#b
d_cop <- subset(D, Copenhagen > 0, select = (Copenhagen))
d_cop <- d_cop[-Copenhagen]
data(eurodist)
n <- 21
D <- as.matrix(eurodist)
is.numeric(D)
#a
D_sub <- subset(D, select = c (Milan, Paris, Rome)) #dovrei selezionare anche le righe
#b
d_cop <- subset(D, Copenhagen > 0, select = (Copenhagen))
d_cop <- d_cop[-Copenhagen]
#c
d_cop_sort <- sort(d_cop)
d_cop[which.max(d_cop)] #distanza tra Copenhagen e la citt? ad essa pi? distante = 3276
d_cop[which.min(d_cop)] #il minimo risulta 0 che per? non va considerato essendo la distanza di Copenhagen con se stessa.
summary(d_cop) #altro modo per ottenere questi valori
#d
sort()
head()
tail()
#e
D_mod <- subset(D, subset = Athens:Vienna > 0)
mean(D_mod)
#a
H <- function (n, alpha){
sum( 1/ ( (1:n)^alpha ) )
}
H(10, 1) #2.928968
#b
dzpif <- function (k, n, alpha){
( k^(-alpha) ) / H(n, alpha)
}
dzpif(5, 10, 2) #0.02581032
#c
n <- 50
alpha <- 1
plot(dzpif(1:n, n, alpha), type="h")
#d
n <- 100
alpha <- 2
sum( dzpif(10:n, n, alpha) ) #0.05823676
#e
rzpif <- function(R, n, alpha){
sample(n, R, replace=TRUE, prob=dzpif)
}
#f
set.seed(123)
R <- 10^5
n <- 50
alpha <- 1
X <- rzpif(R, n, alpha)
mean(X)
#a
lambda0 <- 3
T1 <- function(y){
exp(-mean(y))
}
T2 <- function(y){
mean(y==0)
}
#numerosit? campionarie
nn <- c(300, 500, 1000, 10000, 1000000)
set.seed(123)
lambda_hat1 <- c(
T1(rpois(nn[1], lambda = lambda0)),
T1(rpois(nn[2], lambda = lambda0)),
T1(rpois(nn[3], lambda = lambda0)),
T1(rpois(nn[4], lambda = lambda0)),
T1(rpois(nn[5], lambda = lambda0))
)
lambda_hat1
plot(nn, lambda_hat1,
type = "b",
xlab = "Numerosit? campionaria",
ylab = "Massima verosimiglianza"
)
abline(v=lambda0, col="Deeppink")
#---
set.seed(123)
lambda_hat2 <- c(
T2(rpois(nn[1], lambda = lambda0)),
T2(rpois(nn[2], lambda = lambda0)),
T2(rpois(nn[3], lambda = lambda0)),
T2(rpois(nn[4], lambda = lambda0)),
T2(rpois(nn[5], lambda = lambda0))
)
lambda_hat2
plot(nn, lambda_hat2,
type = "b",
xlab = "Numerosit? campionaria",
ylab = "Massima verosimiglianza"
)
abline(v=lambda0, col="Blue")
#b
set.seed(123)
R <- 10^5
lambda <- 3
n <- 20
mean(lambda_hat1) - lambda0
mean(lambda_hat2) - lambda0
#c
set.seed(123)
R <- 10^5
lambda <- 3
n <- 20
mean((lambda_hat1 - lambda0)^2)
mean((lambda_hat2 - lambda0)^2)
R <- 10^5
n <- 20
T1 <- function(y) {
exp(-mean(y))
}
T2 <- function(y) {
sum(y=0) / n
}
T1_sim <- replicate(R, T1(rpois(n = 20, lambda = 3)))
T2_sim <- replicate(R, T2(rpois(n=20, lambda = 3)))
round(mean(T1_sim - lambda), 2)
round(mean(T2_sim - lambda), 2)
n <- 20
lambda <- 3
mean((T1_sim - lambda)^2)
mean((T2_sim - lambda)^2)
rnorm(100)
