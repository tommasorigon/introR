rnorm(10)
4 * (3 + 5) # La somma entro parentesi viene eseguita per prima
pi / 4 # Pi greco quarti
install.packages(c("downlit", "xml2"))
reddito <- seq(from = 0, to = 200000, length = 200)
library(tidyverse)
setwd("~/Downloads")
redditi <- read_csv("redditi.csv")
View(redditi)
redditi
str(redditi)
glimpse(redditi)
redditi$TIPO_DATO_MEF`
``""
redditi$`TIPO_DATO_MEF`
redditi$`Tipo dato`
redditi %>% filter(`Tipo dato` == "contribuenti per classe di importo")
reddit <- redditi %>% filter(`Tipo dato` == "contribuenti per classe di importo") %>% filter(`Seleziona  anno di imposta` == "2021")
redditi <- read_csv("redditi.csv")
redditi <- redditi %>% filter(`Tipo dato` == "contribuenti per classe di importo") %>% filter(`Seleziona  anno di imposta` == "2020")
rm(reddit)
View(redditi)
View(redditi)
redditi <- redditi %>% filter(`Tipo dato` == "contribuenti per classe di importo") %>% filter(`Seleziona  anno di imposta` == "2020") %>% select(Territorio, `Classe di importo`, Value)
redditi %>% group_by(`Classe di importo`) %>% summarise(contribuenti = sum(Value))
redditi %>% na.onit() %>% group_by(`Classe di importo`) %>% summarise(contribuenti = sum(Value))
redditi %>% na.omit() %>% group_by(`Classe di importo`) %>% summarise(contribuenti = sum(Value))
sum_red <- redditi %>% na.omit() %>% group_by(`Classe di importo`) %>% summarise(contribuenti = sum(Value))
sum_red$contribuenti
sum(sum_red$contribuenti)
levels(redditi$`Classe di importo`)
redditi <- redditi %>% filter(`Tipo dato` == "contribuenti per classe di importo") %>% filter(`Seleziona  anno di imposta` == "2020") %>% select(Territorio, `Classe di importo`, Value)
factor(redditi$`Classe di importo`)
library(tidyverse)
redditi <- read_csv("redditi.csv")
redditi <- redditi %>% filter(`Tipo dato` == "contribuenti per classe di importo") %>% filter(`Seleziona  anno di imposta` == "2020") %>% select(Territorio, `Classe di importo`, Value)
redditi$`Classe di importo` <-  factor(redditi$`Classe di importo`)
levels(redditi$`Classe di importo`)
sum_red <- redditi %>% na.omit() %>% group_by(`Classe di importo`) %>% summarise(contribuenti = sum(Value))
sum_red
View(redditi)
redditi$`Classe di importo` <-  factor(redditi$`Classe di importo`)
levels(redditi$`Classe di importo`)
sum_red <- redditi %>% group_by(`Classe di importo`) %>% summarise(contribuenti = sum(Value))
sum_red
redditi$`Classe di importo` <-  factor(redditi$`Classe di importo`)
levels(redditi$`Classe di importo`)
sum_red <- redditi %>% na.omit() %>% group_by(`Classe di importo`) %>% summarise(contribuenti = sum(Value))
sum_red
redditi$`Classe di importo` <-  factor(redditi$`Classe di importo`)
levels(redditi$`Classe di importo`)
sum_red <- redditi %>% na.omit() %>% group_by(`Classe di importo`) %>% summarise(numero_contribuenti = sum(Value))
sum_red
data(eurodist)
D <- as.matrix(eurodist)
# Parte 1
# 1.A
D_sub <- D[c("Milan", "Paris", "Rome"), c("Milan", "Paris", "Rome")]
D_sub["Rome", "Milan"] #586
# 1.B
d_athens <- D["Athens",]
# 1.C
athens_sort <- sort(d_athens)[-c(1)]
athens_sort[1] # La pi? vicina ? Roma
athens_sort[length(athens_sort)] # La pi? lontana ? Lisbona
# 1.D
D_sort <- sort(D)
D_sort <- D_sort[D_sort>0]
D_sort[1:10] # Prime
D_sort[length(D_sort)-10, length(D_sort)] # Ultime
# Problema 1 ----------------------------------------------------
rm(list = ls())
D <- as.matrix(eurodist)
# 1.1 (2pt)
city_names <- colnames(D)
id_city <- city_names %in% c("Milan", "Paris", "Rome")
# In alternativa:
id_city <- (city_names == "Milan") | (city_names == "Paris") | (city_names == "Rome")
D_sub <- D[id_city, id_city]
D_sub
#       Milan Paris Rome
# Milan     0   856  586
# Paris   856     0 1476
# Rome    586  1476    0
# 1.2 (2pt)
d_athens <- D[city_names == "Athens", !(city_names == "Athens")]
d_athens
# 1.3 (2pt)
sort(d_athens)
names(d_athens)[which.min(d_athens)] # "Rome"
names(d_athens)[which.max(d_athens)] # "Lisbon"
# 1.4, 1.5 ed 1.6 (4pt)
# Soluzione concettualmente semplice ma lunga ed inefficiente
minimum <- D[2, 1]
maximum <- D[2, 1]
pos_min <- c(1, 1)
pos_max <- c(1, 1)
S <- 0 # Somma dei valori
n <- 0 # Conteggio delle osservazioni
for(i in 2:21){
for(j in 1:(i-1)){
n <- n + 1
S <- S + D[i, j]
if(D[i, j] < minimum){
minimum <- D[i, j]
pos_min <- c(i, j)
}
if(D[i, j] > maximum){
maximum <- D[i, j]
pos_max <- c(i, j)
}
}
}
# Città più vicine
c(city_names[pos_min[1]], city_names[pos_min[2]])
# Città più distanti
c(city_names[pos_max[1]], city_names[pos_max[2]])
# Media delle distanze
S / n
# Alternativa, elegante
mean(D[lower.tri(D)])
# 1.6 (2pt)
S2 <- 0 # Somma delle distanze
for(i in 1:21){
for(j in 1:21){
S2 <- S2 + D[i, j]^2
}
}
S2 / (2 * 21)
# Oppure
sum(D^2) / (2 * 21)
erf_approx <- function(x,N){
indexes <- 0:N
2/sqrt(pi)*sum((-1)^indexes*x^(2*indexes+1)/(factorial(indexes)*(2*indexes+1)))
}
pnorm_approx <- function(x,N){
indexes <- 0:N
indexes*erf_approx(x,N)
}
round(erf_approx(0,10),2)
round(erf_approx(1,10),2)
round(erf_approx(2,10),2)
mean(pnorm_approx(0,10))
mean(pnorm_approx(1,10))
mean(pnorm_approx(2,10))
mean(pnorm_approx(-3,10))
MonteCarlo <- function(R){
X <- rnorm(R)
estimate <- mean(X)
std.error <- sqrt(estimate * (1 - estimate) / R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error") # Aggiungo solo per ragioni estetiche
out
}
MonteCarlo(100000)
pnorm(-3)
R <- 10^5
X <- sample(20, size=R, replace=TRUE)
mean(X+3>=15)
Z <- numeric(R)
X1 <- sample(20, size=R, replace=TRUE)
X2 <- sample(20, size=R, replace=TRUE)
for (i in 1:length(X1)){
if (X1[i]>X2[i]) Z[i]=X1[i]
else Z[i]=X2[i]
}
hist(Z, xlab="Risultato", ylab="R")
rm(list = ls())
erf_approx <- function(x,N){
indexes <- 0:N
2/sqrt(pi)*sum((-1)^indexes*x^(2*indexes+1)/(factorial(indexes)*(2*indexes+1)))
}
pnorm_approx <- function(x,N){
indexes <- 0:N
indexes*erf_approx(x,N)
}
# 2.B
round(erf_approx(0,10),2)
round(erf_approx(1,10),2)
round(erf_approx(2,10),2)
mean(pnorm_approx(0,10))
mean(pnorm_approx(1,10))
mean(pnorm_approx(2,10))
# 2.2 e 2.3 (6pt)
rbind(
c(erf_approx(x = 0, N = 10), pnorm_approx(x = 0, N = 10), pnorm(0)),
c(erf_approx(x = 1, N = 10), pnorm_approx(x = 1, N = 10), pnorm(1)),
c(erf_approx(x = 2, N = 10), pnorm_approx(x = 2, N = 10), pnorm(2))
)
c(pnorm_approx(x = -3, N = 10), pnorm(-3))
# 2.1 (3pt)
erf_approx <- function(x, N) {
indexes <- 0:N
values <- (-1)^indexes * x^(2 * indexes + 1) / (factorial(indexes) * (2 * indexes + 1))
2 / sqrt(pi) * sum(values)
}
pnorm_approx <- function(x, N) {
0.5 * (1 + erf_approx(x / sqrt(2), N))
}
# Nota: rbind è usato solamente per migliorare la resa estetica
# 2.2 e 2.3 (6pt)
rbind(
c(erf_approx(x = 0, N = 10), pnorm_approx(x = 0, N = 10), pnorm(0)),
c(erf_approx(x = 1, N = 10), pnorm_approx(x = 1, N = 10), pnorm(1)),
c(erf_approx(x = 2, N = 10), pnorm_approx(x = 2, N = 10), pnorm(2))
)
c(pnorm_approx(x = -3, N = 10), pnorm(-3))
data(eurodist)
D <- as.matrix(eurodist)
data(eurodist)
D <- as.matrix(eurodist)
D_sub <- D[c("Milan", "Paris", "Rome"), c("Milan", "Paris", "Rome")]
D_sub["Rome", "Milan"] #586
d_athens <- D["Athens",]
athens_sort <- sort(d_athens)[-c(1)]
athens_sort[1] # La pi? vicina ? Roma
athens_sort[length(athens_sort)] # La pi? lontana ? Lisbona
D_sort <- sort(D)
D_sort <- D_sort[D_sort>0]
D_sort[1:10] # Prime
D_sort[length(D_sort)-10, length(D_sort)] # Ultime
rm(list=ls())
data(eurodist)
D <- as.matrix(eurodist)
D_sub <- D[c("Milan", "Paris", "Rome"), c("Milan", "Paris", "Rome")]
D_sub["Rome", "Milan"] #586
d_athens <- D["Athens",]
athens_sort <- sort(d_athens)[-c(1)]
athens_sort[1] # La pi? vicina ? Roma
athens_sort[length(athens_sort)] # La pi? lontana ? Lisbona
D_sort <- sort(D)
D_sort <- D_sort[D_sort>0]
D_sort[1:10] # Prime
D_sort[length(D_sort)-10, length(D_sort)] # Ultime
# 1.E
newD <- D[D>0]
mean(newD)
mean(D[lower.tri(D)])
var <- function(x){
somma <- 0
for (j in 1:ncol(x)){
for (i in 1:nrow(x)){
somma <- somma+(D[i,j])^2
}
}
ris <- somma/(2*ncol(x))
ris
}
var(D)
S2 <- 0 # Somma delle distanze
for(i in 1:21){
for(j in 1:21){
S2 <- S2 + D[i, j]^2
}
}
S2 / (2 * 21)
# Oppure
sum(D^2) / (2 * 21)
d_athens <- D["Athens",]
athens_sort <- sort(d_athens)[-c(1)]
athens_sort[1] # La pi? vicina ? Roma
athens_sort[length(athens_sort)] # La pi? lontana ? Lisbona
data(eurodist)
D <- as.matrix(eurodist)
D_sub <- D[c("Milan", "Paris", "Rome"), c("Milan", "Paris", "Rome")]
data(eurodist)
D <- as.matrix(eurodist)
D_sub <- D[c("Milan", "Paris", "Rome"), c("Milan", "Paris", "Rome")]
D_sub["Rome", "Milan"] #586
D_sub <- D[c("Milan", "Paris", "Rome"), c("Milan", "Paris", "Rome")]
D_sub
D_sub
# 1.2 (2pt)
d_athens <- D[city_names == "Athens", !(city_names == "Athens")]
d_athens
# 1.1 (2pt)
city_names <- colnames(D)
id_city <- city_names %in% c("Milan", "Paris", "Rome")
# In alternativa:
id_city <- (city_names == "Milan") | (city_names == "Paris") | (city_names == "Rome")
# 1.2 (2pt)
d_athens <- D[city_names == "Athens", !(city_names == "Athens")]
d_athens
D["Athens",]
# 3.B
Z <- numeric(R)
R <- 10^5
X <- sample(20, size=R, replace=TRUE)
mean(X+3>=15)
Z <- numeric(R)
X1 <- sample(20, size=R, replace=TRUE)
X2 <- sample(20, size=R, replace=TRUE)
for (i in 1:length(X1)){
if (X1[i]>X2[i]) Z[i]=X1[i]
else Z[i]=X2[i]
}
hist(Z, xlab="Risultato", ylab="R")
mean(Z+3>=15) # S?, al giocatore ? concesso un vantaggio poich? la probabilit? ? pi? alta
MonteCarlo <- function(R){
X1 <- sample(20, size=R, replace=TRUE)
X2 <- sample(20, size=R, replace=TRUE)
for (i in 1:length(X1)){
if (X1[i]>X2[i]) Z[i]=X1[i]
else Z[i]=X2[i]
}
Z <- mean(Z+3>=15)
estimate <- mean(Z)
std.error <- sqrt(estimate * (1 - estimate) / R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error") # Aggiungo solo per ragioni estetiche
out
}
MonteCarlo(1000)
MonteCarlo(10000)
MonteCarlo(100000)
MonteCarlo <- function(R){
X1 <- sample(20, size=R, replace=TRUE)
X2 <- sample(20, size=R, replace=TRUE)
for (i in 1:length(X1)){
if (X1[i]>X2[i]) Z[i]=X1[i]
else Z[i]=X2[i]
}
Z <- mean(Z+3>=15)
estimate <- mean(Z)
std.error <- sqrt(estimate * (1 - estimate) / R)
out <- c(estimate, std.error)
names(out) <- c("estimate", "std.error") # Aggiungo solo per ragioni estetiche
out
}
MonteCarlo(1000)
MonteCarlo(10000)
MonteCarlo(100000)
set.seed(100)
n <- 10^5 # Numero di simulazioni da effettuare
x <- sample(1:20, size = n, replace = TRUE) # Campiono n volte il dado da 20.
mean(x + 5 >= 17) # Stimo la probabilità dell'evento
set.seed(100)
# La funzione pmax seleziona il massimo di ciascuna coppia
z <- pmax(sample(1:20, size = n, replace = TRUE), sample(1:20, size = n, replace = TRUE))
freq_rel <- table(z) / n
plot(freq_rel) # Rappresentazione grafica
freq_rel <- table(z) / n
plot(freq_rel) # Rappresentazione grafica
mean(z + 5 >= 17) # La probabilità è più alta rispetto a quella ottenuta al punto C.1
reticulate::repl_python()
